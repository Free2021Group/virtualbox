Index: src/VBox/Additions/common/crOpenGL/egl.c
===================================================================
--- a/src/VBox/Additions/common/crOpenGL/egl.c
+++ b/src/VBox/Additions/common/crOpenGL/egl.c
@@ -21,8 +21,5 @@
 *******************************************************************************/
 #include <iprt/cdefs.h>
-#include <iprt/initterm.h>
-#include <iprt/mem.h>
-#include <iprt/once.h>
-#include <iprt/thread.h>
+#include <iprt/types.h>
 
 #include <EGL/egl.h>
@@ -30,5 +27,11 @@
 #include <X11/Xlib.h>
 
+#include <dlfcn.h>
+#include <pthread.h>
+#include <stdio.h>
 #include <stdlib.h>
+
+#define EGL_ASSERT(expr) \
+    if (!(expr)) { printf("Assertion failed: %s\n", #expr); exit(1); }
 
 /*******************************************************************************
@@ -72,14 +75,12 @@
 *******************************************************************************/
 
-static RTTLS    g_tls = NIL_RTTLS;
-static RTONCE   g_tlsOnce = RTONCE_INITIALIZER;
-static Display *g_pDefaultDisplay = NULL;
-static RTONCE   g_defaultDisplayOnce = RTONCE_INITIALIZER;
-
-static DECLCALLBACK(int32_t) tlsInitOnce(void *pv)
-{
-    NOREF(pv);
-    g_tls = RTTlsAlloc();
-    return VINF_SUCCESS;
+static pthread_key_t  g_tls;
+static pthread_once_t g_tlsOnce = PTHREAD_ONCE_INIT;
+static Display       *g_pDefaultDisplay = NULL;
+static pthread_once_t g_defaultDisplayOnce = PTHREAD_ONCE_INIT;
+
+static void tlsInitOnce(void)
+{
+    pthread_key_create(&g_tls, NULL);
 }
 
@@ -88,9 +89,9 @@
     struct VBEGLTLS *pTls;
 
-    RTOnce(&g_tlsOnce, tlsInitOnce, NULL);
-    pTls = (struct VBEGLTLS *)RTTlsGet(g_tls);
+    pthread_once(&g_tlsOnce, tlsInitOnce);
+    pTls = (struct VBEGLTLS *)pthread_getspecific(g_tls);
     if (RT_LIKELY(pTls))
         return pTls;
-    pTls = (struct VBEGLTLS *)RTMemAlloc(sizeof(*pTls));
+    pTls = (struct VBEGLTLS *)malloc(sizeof(*pTls));
     if (!VALID_PTR(pTls))
         return NULL;
@@ -101,13 +102,13 @@
     pTls->hCurrentDraw = EGL_NO_SURFACE;
     pTls->hCurrentRead = EGL_NO_SURFACE;
-    RTTlsSet(g_tls, pTls);
-    return pTls;
-}
-
-static DECLCALLBACK(int32_t) defaultDisplayInitOnce(void *pv)
-{
-    NOREF(pv);
+    if (pthread_setspecific(g_tls, pTls) == 0)
+        return pTls;
+    free(pTls);
+    return NULL;
+}
+
+static void defaultDisplayInitOnce(void)
+{
     g_pDefaultDisplay = XOpenDisplay(NULL);
-    return VINF_SUCCESS;
 }
 
@@ -131,15 +132,24 @@
 }
 
+static EGLBoolean testValidDisplay(EGLNativeDisplayType hDisplay)
+{
+    if (hDisplay == EGL_DEFAULT_DISPLAY)
+        return EGL_TRUE;
+    if ((void *)hDisplay == NULL)
+        return EGL_FALSE;
+    /* This is the test that Mesa uses to see if this is a GBM "display".  Not
+     * very pretty, but since no one can afford to break Mesa it should be
+     * safe. Obviously we can't support GBM for now. */
+    if (*(void **)hDisplay == dlsym(NULL, "gbm_create_device"))
+        return EGL_FALSE;
+    return EGL_TRUE;
+}
+
 DECLEXPORT(EGLDisplay) eglGetDisplay(EGLNativeDisplayType hDisplay)
 {
     Display *pDisplay;
     int rc, cError, cEvent, cMajor, cMinor;
-    /* Prevent working from inside the X server by requiring a valid DISPLAY. */
-    char *pszDisplay = getenv("DISPLAY");
-    
-    if (!pszDisplay || !*pszDisplay)
-        return EGL_NO_DISPLAY;
-    rc = RTR3InitDll(RTR3INIT_FLAGS_UNOBTRUSIVE);
-    if (RT_FAILURE(rc))
+
+    if (!testValidDisplay(hDisplay))
         return EGL_NO_DISPLAY;
     if (!clearEGLError())  /* Set up our tls. */
@@ -149,5 +159,5 @@
     else
     {
-        RTOnce(&g_defaultDisplayOnce, defaultDisplayInitOnce, NULL);
+        pthread_once(&g_defaultDisplayOnce, defaultDisplayInitOnce);
         pDisplay = g_pDefaultDisplay;
     }
@@ -170,8 +180,5 @@
 DECLEXPORT(EGLBoolean) eglInitialize (EGLDisplay hDisplay, EGLint *pcMajor, EGLint *pcMinor)
 {
-    /* Prevent working from inside the X server by requiring a valid DISPLAY. */
-    char *pszDisplay = getenv("DISPLAY");
-    
-    if (!pszDisplay || !*pszDisplay)
+    if (hDisplay == EGL_NO_DISPLAY)
         return EGL_FALSE;
     if (!VALID_PTR(hDisplay))
@@ -222,5 +229,6 @@
         return setEGLError(EGL_BAD_PARAMETER);
     paFBConfigs = glXGetFBConfigs(pDisplay, DefaultScreen(pDisplay), &caFBConfigs);
-    AssertPtrReturn(paFBConfigs, setEGLError(EGL_BAD_PARAMETER));
+    if (!VALID_PTR(paFBConfigs))
+        return setEGLError(EGL_BAD_PARAMETER);
     if (caFBConfigs > caConfigs)
         caFBConfigs = caConfigs;
@@ -426,5 +434,5 @@
     {
         aAttribList[cAttribs] = None;
-        AssertRelease(cAttribs < RT_ELEMENTS(aAttribList));
+        EGL_ASSERT(cAttribs < RT_ELEMENTS(aAttribList));
         if (!(cRenderableType & EGL_OPENGL_BIT))
             return setEGLError(EGL_BAD_ACCESS);
@@ -559,5 +567,5 @@
         return EGL_NO_SURFACE;
     }
-    AssertRelease(hGLXWindow < VBEGL_WINDOW_SURFACE);  /* Greater than the maximum XID. */
+    EGL_ASSERT(hGLXWindow < VBEGL_WINDOW_SURFACE);  /* Greater than the maximum XID. */
     clearEGLError();
     return (EGLSurface)(hGLXWindow | VBEGL_WINDOW_SURFACE);
@@ -627,5 +635,5 @@
             paAttributes += 2;
         }
-    AssertRelease(cIndex < RT_ELEMENTS(aAttributes) - 1);
+    EGL_ASSERT(cIndex < RT_ELEMENTS(aAttributes) - 1);
     aAttributes[cIndex + 1] = None;
     hPbuffer = glXCreatePbuffer(pDisplay, (GLXFBConfig)config, aAttributes);
@@ -635,5 +643,5 @@
         return EGL_NO_SURFACE;
     }
-    AssertRelease(hPbuffer < VBEGL_WINDOW_SURFACE);  /* Greater than the maximum XID. */
+    EGL_ASSERT(hPbuffer < VBEGL_WINDOW_SURFACE);  /* Greater than the maximum XID. */
     clearEGLError();
     return (EGLSurface)(hPbuffer | VBEGL_PBUFFER_SURFACE);
@@ -671,5 +679,5 @@
         return EGL_NO_SURFACE;
     }
-    AssertRelease(hGLXPixmap < VBEGL_WINDOW_SURFACE);  /* Greater than the maximum XID. */
+    EGL_ASSERT(hGLXPixmap < VBEGL_WINDOW_SURFACE);  /* Greater than the maximum XID. */
     clearEGLError();
     return (EGLSurface)(hGLXPixmap | VBEGL_PIXMAP_SURFACE);
@@ -741,9 +749,4 @@
 DECLEXPORT(EGLBoolean) eglBindAPI(EGLenum enmApi)
 {
-    /* Prevent working from inside the X server by requiring a valid DISPLAY. */
-    char *pszDisplay = getenv("DISPLAY");
-    
-    if (!pszDisplay || !*pszDisplay)
-        return EGL_FALSE;
     return enmApi == EGL_OPENGL_API ? clearEGLError() : setEGLError(EGL_BAD_PARAMETER);
 }
@@ -842,6 +845,7 @@
 DECLEXPORT(EGLDisplay) eglGetCurrentDisplay(void)
 {
-    struct VBEGLTLS *pTls = getTls();
-
+    struct VBEGLTLS *pTls;
+
+    pTls = getTls();
     if (!VALID_PTR(pTls))
         return EGL_NO_DISPLAY;
@@ -947,6 +951,7 @@
     if (!(pTls))
         return EGL_TRUE;
-    RTMemFree(pTls);
-    RTTlsSet(g_tls, NULL);
+    free(pTls);
+    /* Can this fail with ENOMEM? */
+    pthread_setspecific(g_tls, NULL);
     return EGL_TRUE;
 }
