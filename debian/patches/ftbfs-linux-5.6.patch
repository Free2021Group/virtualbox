--- virtualbox.orig/include/iprt/time.h
+++ virtualbox/include/iprt/time.h
@@ -366,6 +366,7 @@ DECLINLINE(void) RTTimeSpecGetSecondsAndNano(PRTTIMESPEC pTime, int32_t *pi32Sec
  * @param   pTime       The time spec to interpret.
  * @param   pTimeval    Where to store the time as POSIX timeval.
  */
+#if !(LINUX_VERSION_CODE >= KERNEL_VERSION(5, 6, 0))
 DECLINLINE(struct timeval *) RTTimeSpecGetTimeval(PCRTTIMESPEC pTime, struct timeval *pTimeval)
 {
     int64_t i64 = RTTimeSpecGetMicro(pTime);
@@ -392,6 +393,7 @@ DECLINLINE(PRTTIMESPEC) RTTimeSpecSetTimeval(PRTTIMESPEC pTime, const struct tim
 {
     return RTTimeSpecAddMicro(RTTimeSpecSetSeconds(pTime, pTimeval->tv_sec), pTimeval->tv_usec);
 }
+#endif
 #endif /* various ways of detecting struct timeval */
 
 
@@ -405,6 +407,7 @@ DECLINLINE(PRTTIMESPEC) RTTimeSpecSetTimeval(PRTTIMESPEC pTime, const struct tim
  * @param   pTime       The time spec to interpret.
  * @param   pTimespec   Where to store the time as POSIX timespec.
  */
+#if !(LINUX_VERSION_CODE >= KERNEL_VERSION(5, 6, 0))
 DECLINLINE(struct timespec *) RTTimeSpecGetTimespec(PCRTTIMESPEC pTime, struct timespec *pTimespec)
 {
     int64_t i64 = RTTimeSpecGetNano(pTime);
@@ -432,6 +435,8 @@ DECLINLINE(PRTTIMESPEC) RTTimeSpecSetTimespec(PRTTIMESPEC pTime, const struct ti
     return RTTimeSpecAddNano(RTTimeSpecSetSeconds(pTime, pTimespec->tv_sec), pTimespec->tv_nsec);
 }
 
+#endif
+#endif /* various ways of detecting struct timespec */
 
 # ifdef _LINUX_TIME64_H
 DECLINLINE(PRTTIMESPEC) RTTimeSpecSetTimespec64(PRTTIMESPEC pTime, const struct timespec64 *pTimeval)
@@ -439,7 +444,6 @@ DECLINLINE(PRTTIMESPEC) RTTimeSpecSetTimespec64(PRTTIMESPEC pTime, const struct
     return RTTimeSpecAddNano(RTTimeSpecSetSeconds(pTime, pTimeval->tv_sec), pTimeval->tv_nsec);
 }
 # endif
-#endif /* various ways of detecting struct timespec */
 
 
 
--- virtualbox.orig/src/VBox/Runtime/r0drv/linux/memobj-r0drv-linux.c
+++ virtualbox/src/VBox/Runtime/r0drv/linux/memobj-r0drv-linux.c
@@ -1461,9 +1461,13 @@ DECLHIDDEN(int) rtR0MemObjNativeMapKernel(PPRTR0MEMOBJINTERNAL ppMem, RTR0MEMOBJ
              * MMIO / physical memory.
              */
             Assert(pMemLnxToMap->Core.enmType == RTR0MEMOBJTYPE_PHYS && !pMemLnxToMap->Core.u.Phys.fAllocated);
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 6, 0)
+            pMemLnx->Core.pv = ioremap(pMemLnxToMap->Core.u.Phys.PhysBase + offSub, cbSub);
+#else
             pMemLnx->Core.pv = pMemLnxToMap->Core.u.Phys.uCachePolicy == RTMEM_CACHE_POLICY_MMIO
                              ? ioremap_nocache(pMemLnxToMap->Core.u.Phys.PhysBase + offSub, cbSub)
                              : ioremap(pMemLnxToMap->Core.u.Phys.PhysBase + offSub, cbSub);
+#endif
             if (pMemLnx->Core.pv)
             {
                 /** @todo fix protection. */
--- virtualbox.orig/src/VBox/Runtime/r0drv/linux/time-r0drv-linux.c
+++ virtualbox/src/VBox/Runtime/r0drv/linux/time-r0drv-linux.c
@@ -43,8 +43,8 @@ DECLINLINE(uint64_t) rtTimeGetSystemNanoTS(void)
      * Use ktime_get_ts, this is also what clock_gettime(CLOCK_MONOTONIC,) is using.
      */
     uint64_t u64;
-    struct timespec Ts;
-    ktime_get_ts(&Ts);
+    struct timespec64 Ts;
+    ktime_get_ts64(&Ts);
     u64 = Ts.tv_sec * RT_NS_1SEC_64 + Ts.tv_nsec;
     return u64;
 
