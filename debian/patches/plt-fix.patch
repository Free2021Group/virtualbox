Description: "VMMR0.r0 has been built (presumably due to the recent binutils upgrades in unstable) with the new PLT32 relocation type, which the virtualbox ELF relocation code cannot handle at the moment. Having a quick glance at .text and .rela.text of VMMR0.r0, it seems to me that PC32 and PLT32 can be handled identically, similar to what commit b21ebf2fb4cd of the Linux kernel did?"

--- virtualbox-5.2.14-dfsg.orig/src/VBox/Devices/EFI/Firmware/BaseTools/Source/C/GenFw/Elf64Convert.c
+++ virtualbox-5.2.14-dfsg/src/VBox/Devices/EFI/Firmware/BaseTools/Source/C/GenFw/Elf64Convert.c
@@ -691,6 +691,19 @@ WriteSections64 (
               - (SecOffset - SecShdr->sh_addr));
             VerboseMsg ("Relocation:  0x%08X", *(UINT32 *)Targ);
             break;
+          case R_X86_64_PLT32:
+            //
+            // Relative relocation: Symbol - Ip + Addend
+            //
+            VerboseMsg ("R_X86_64_PLT32");
+            VerboseMsg ("Offset: 0x%08X, Addend: 0x%08X",
+              (UINT32)(SecOffset + (Rel->r_offset - SecShdr->sh_addr)),
+              *(UINT32 *)Targ);
+            *(UINT32 *)Targ = (UINT32) (*(UINT32 *)Targ
+              + (mCoffSectionsOffset[Sym->st_shndx] - SymShdr->sh_addr)
+              - (SecOffset - SecShdr->sh_addr));
+            VerboseMsg ("Relocation:  0x%08X", *(UINT32 *)Targ);
+            break;
           default:
             Error (NULL, 0, 3000, "Invalid", "%s unsupported ELF EM_X86_64 relocation 0x%x.", mInImageName, (unsigned) ELF_R_TYPE(Rel->r_info));
           }
@@ -785,6 +798,7 @@ WriteRelocations64 (
             switch (ELF_R_TYPE(Rel->r_info)) {
             case R_X86_64_NONE:
             case R_X86_64_PC32:
+            case R_X86_64_PLT32:
               break;
             case R_X86_64_64:
               VerboseMsg ("EFI_IMAGE_REL_BASED_DIR64 Offset: 0x%08X",
--- virtualbox-5.2.14-dfsg.orig/src/VBox/Devices/PC/ipxe/src/util/elf2efi.c
+++ virtualbox-5.2.14-dfsg/src/VBox/Devices/PC/ipxe/src/util/elf2efi.c
@@ -486,7 +486,8 @@ static void process_reloc ( bfd *bfd __a
 		/* Generate a 2-byte PE relocation */
 		generate_pe_reloc ( pe_reltab, offset, 2 );
 	} else if ( ( strcmp ( howto->name, "R_386_PC32" ) == 0 ) ||
-		    ( strcmp ( howto->name, "R_X86_64_PC32" ) == 0 ) ) {
+		    ( strcmp ( howto->name, "R_X86_64_PC32" ) == 0 ) ||
+		    ( strcmp ( howto->name, "R_X86_64_PLT32" ) == 0 ) ) {
 		/* Skip PC-relative relocations; all relative offsets
 		 * remain unaltered when the object is loaded.
 		 */
--- virtualbox-5.2.14-dfsg.orig/src/VBox/Runtime/common/ldr/ldrELFRelocatable.cpp.h
+++ virtualbox-5.2.14-dfsg/src/VBox/Runtime/common/ldr/ldrELFRelocatable.cpp.h
@@ -368,6 +368,20 @@ static int RTLDRELF_NAME(RelocateSection
                 AssertMsgReturn((Elf_Addr)*(int32_t *)pAddrW == Value, ("Value=" FMT_ELF_ADDR "\n", Value), VERR_SYMBOL_VALUE_TOO_BIG); /** @todo check the sign-extending here. */
                 break;
             }
+
+            /*
+             * PC relative addressing.
+             */
+            case R_X86_64_PLT32:
+            {
+                const Elf_Addr SourceAddr = SecAddr + paRels[iRel].r_offset + BaseAddr; /* Where the source really is. */
+                Value -= SourceAddr;
+                *(int32_t *)pAddrW = (int32_t)Value;
+                Log4((FMT_ELF_ADDR": R_X86_64_PLT32 Value=" FMT_ELF_ADDR " SymValue=" FMT_ELF_ADDR "\n",
+                      SourceAddr, Value, SymValue));
+                AssertMsgReturn((Elf_Addr)*(int32_t *)pAddrW == Value, ("Value=" FMT_ELF_ADDR "\n", Value), VERR_SYMBOL_VALUE_TOO_BIG); /** @todo check the sign-extending here. */
+                break;
+            }
 #endif
 
             default:
@@ -639,6 +653,20 @@ static int RTLDRELF_NAME(RelocateSection
                       SourceAddr, Value, SymValue));
                 AssertMsgReturn((Elf_Addr)*(int32_t *)pAddrW == Value, ("Value=" FMT_ELF_ADDR "\n", Value), VERR_SYMBOL_VALUE_TOO_BIG); /** @todo check the sign-extending here. */
                 break;
+            }
+
+            /*
+             * PC relative addressing.
+             */
+            case R_X86_64_PLT32:
+            {
+                const Elf_Addr SourceAddr = SecAddr + paRels[iRel].r_offset + BaseAddr; /* Where the source really is. */
+                const Elf_Addr Value = SymValue + paRels[iRel].r_addend - SourceAddr;
+                *(int32_t *)pAddrW = (int32_t)Value;
+                Log4((FMT_ELF_ADDR": R_X86_64_PLT32 Value=" FMT_ELF_ADDR " SymValue=" FMT_ELF_ADDR "\n",
+                      SourceAddr, Value, SymValue));
+                AssertMsgReturn((Elf_Addr)*(int32_t *)pAddrW == Value, ("Value=" FMT_ELF_ADDR "\n", Value), VERR_SYMBOL_VALUE_TOO_BIG); /** @todo check the sign-extending here. */
+                break;
             }
 
             /* ignore */
--- virtualbox-5.2.14-dfsg.orig/src/VBox/ValidationKit/bootsectors/bs3kit/VBoxBs3ObjConverter.cpp
+++ virtualbox-5.2.14-dfsg/src/VBox/ValidationKit/bootsectors/bs3kit/VBoxBs3ObjConverter.cpp
@@ -1878,6 +1878,19 @@ static bool convertElfSectionsToLeDataAn
 
                     case R_X86_64_GOT32:
                     case R_X86_64_PLT32:
+                    {
+                        /* defaults are ok, just handle the addend. */
+                        int32_t iAddend = paRelocs[iReloc].r_addend;
+                        if (iAddend != paRelocs[iReloc].r_addend)
+                            fRet = error(pThis->pszSrc, "R_X86_64_PLT32 with large addend (%d) at %#x in segment #%u '%s'\n",
+                                         iAddend, paRelocs[iReloc].r_offset, i, pszSegNm);
+                        if (fSelfRel)
+                            *uLoc.pu32 = iAddend + 4;
+                        else
+                            *uLoc.pu32 = iAddend;
+                        break;
+                    }
+
                     case R_X86_64_COPY:
                     case R_X86_64_GLOB_DAT:
                     case R_X86_64_JMP_SLOT:
@@ -3564,6 +3577,16 @@ static bool convertMachOSectionsToLeData
 
                     case R_X86_64_GOT32:
                     case R_X86_64_PLT32:
+                    {
+                        /* defaults are ok, just handle the addend. */
+                        int32_t iAddend = paRelocs[iReloc].r_addend;
+                        if (iAddend != paRelocs[iReloc].r_addend)
+                            fRet = error(pThis->pszSrc, "R_X86_64_PLT32 with large addend (%d) at %#x in segment #%u '%s'\n",
+                                         iAddend, paRelocs[iReloc].r_offset, i, pszSegNm);
+                        *uLoc.pu32 = iAddend;
+                        break;
+                    }
+
                     case R_X86_64_COPY:
                     case R_X86_64_GLOB_DAT:
                     case R_X86_64_JMP_SLOT:
