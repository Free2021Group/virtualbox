Description: Don't reschedule after clearing the inhibit irq flag, it breaks sti+hlt sequences
 by continuing execution instead of halting.
 Restore the previous state on resume if we were halted or in a sipi wait.
Origin: upstream, https://www.virtualbox.org/changeset/38612/vbox
Bug: https://www.virtualbox.org/ticket/10370

--- a/src/VBox/VMM/VMMR3/EM.cpp
+++ b/src/VBox/VMM/VMMR3/EM.cpp
@@ -1360,8 +1360,9 @@
             rc2 = VMMR3EmtRendezvousFF(pVM, pVCpu);
             UPDATE_RC();
-            /** @todo HACK ALERT! The following test is to make sure EM+TM things the VM is
-             * stopped/reset before the next VM state change is made. We need a better
-             * solution for this, or at least make it possible to do: (rc >= VINF_EM_FIRST
-             * && rc >= VINF_EM_SUSPEND). */
+            /** @todo HACK ALERT! The following test is to make sure EM+TM
+             * thinks the VM is stopped/reset before the next VM state change
+             * is made. We need a better solution for this, or at least make it
+             * possible to do: (rc >= VINF_EM_FIRST && rc <=
+             * VINF_EM_SUSPEND). */
             if (RT_UNLIKELY(rc == VINF_EM_SUSPEND || rc == VINF_EM_RESET || rc == VINF_EM_OFF))
             {
@@ -1470,8 +1471,9 @@
             rc2 = VMMR3EmtRendezvousFF(pVM, pVCpu);
             UPDATE_RC();
-            /** @todo HACK ALERT! The following test is to make sure EM+TM things the VM is
-             * stopped/reset before the next VM state change is made. We need a better
-             * solution for this, or at least make it possible to do: (rc >= VINF_EM_FIRST
-             * && rc >= VINF_EM_SUSPEND). */
+            /** @todo HACK ALERT! The following test is to make sure EM+TM
+             * thinks the VM is stopped/reset before the next VM state change
+             * is made. We need a better solution for this, or at least make it
+             * possible to do: (rc >= VINF_EM_FIRST && rc <=
+             * VINF_EM_SUSPEND). */
             if (RT_UNLIKELY(rc == VINF_EM_SUSPEND || rc == VINF_EM_RESET || rc == VINF_EM_OFF))
             {
@@ -1495,8 +1497,9 @@
             }
             UPDATE_RC();
-            /** @todo HACK ALERT! The following test is to make sure EM+TM things the VM is
-             * stopped/reset before the next VM state change is made. We need a better
-             * solution for this, or at least make it possible to do: (rc >= VINF_EM_FIRST
-             * && rc >= VINF_EM_SUSPEND). */
+            /** @todo HACK ALERT! The following test is to make sure EM+TM
+             * thinks the VM is stopped/reset before the next VM state change
+             * is made. We need a better solution for this, or at least make it
+             * possible to do: (rc >= VINF_EM_FIRST && rc <=
+             * VINF_EM_SUSPEND). */
             if (RT_UNLIKELY(rc == VINF_EM_SUSPEND || rc == VINF_EM_RESET || rc == VINF_EM_OFF))
             {
@@ -1546,8 +1549,9 @@
             }
             UPDATE_RC();
-            /** @todo HACK ALERT! The following test is to make sure EM+TM things the VM is
-             * stopped/reset before the next VM state change is made. We need a better
-             * solution for this, or at least make it possible to do: (rc >= VINF_EM_FIRST
-             * && rc >= VINF_EM_SUSPEND). */
+            /** @todo HACK ALERT! The following test is to make sure EM+TM
+             * thinks the VM is stopped/reset before the next VM state change
+             * is made. We need a better solution for this, or at least make it
+             * possible to do: (rc >= VINF_EM_FIRST && rc <=
+             * VINF_EM_SUSPEND). */
             if (RT_UNLIKELY(rc == VINF_EM_SUSPEND || rc == VINF_EM_RESET || rc == VINF_EM_OFF))
             {
@@ -1578,5 +1582,5 @@
         /*
          * The instruction following an emulated STI should *always* be executed!
-         * 
+         *
          * Note! We intentionally don't clear VM_FF_INHIBIT_INTERRUPTS here if
          *       the eip is the same as the inhibited instr address.  Before we
@@ -1591,16 +1595,11 @@
             &&  !VM_FF_ISPENDING(pVM, VM_FF_PGM_NO_MEMORY))
         {
-            Log(("VMCPU_FF_INHIBIT_INTERRUPTS at %RGv successor %RGv\n", (RTGCPTR)CPUMGetGuestRIP(pVCpu), EMGetInhibitInterruptsPC(pVCpu)));
             if (CPUMGetGuestRIP(pVCpu) != EMGetInhibitInterruptsPC(pVCpu))
+            {
+                Log(("Clearing VMCPU_FF_INHIBIT_INTERRUPTS at %RGv - successor %RGv\n", (RTGCPTR)CPUMGetGuestRIP(pVCpu), EMGetInhibitInterruptsPC(pVCpu)));
                 VMCPU_FF_CLEAR(pVCpu, VMCPU_FF_INHIBIT_INTERRUPTS);
-
-            if (EMIsSupervisorCodeRecompiled(pVM))
-                rc2 = VINF_EM_RESCHEDULE_REM;
-            else if (HWACCMR3IsActive(pVCpu))
-                rc2 = VINF_EM_RESCHEDULE_HWACC;
+            }
             else
-                rc2 = PATMAreInterruptsEnabled(pVM) ? VINF_EM_RESCHEDULE_RAW : VINF_EM_RESCHEDULE_REM;
-
-            UPDATE_RC();
+                Log(("Leaving VMCPU_FF_INHIBIT_INTERRUPTS set at %RGv\n", (RTGCPTR)CPUMGetGuestRIP(pVCpu)));
         }
 
@@ -1900,5 +1899,8 @@
                     if (    pVCpu->em.s.enmPrevState == EMSTATE_WAIT_SIPI
                         ||  pVCpu->em.s.enmPrevState == EMSTATE_HALTED)
+                    {
+                        pVCpu->em.s.enmState = pVCpu->em.s.enmPrevState;
                         break;
+                    }
                     /* fall through and get scheduled. */
 
@@ -1937,4 +1939,5 @@
                 case VINF_EM_SUSPEND:
                     Log2(("EMR3ExecuteVM: VINF_EM_SUSPEND: %d -> %d\n", pVCpu->em.s.enmState, EMSTATE_SUSPENDED));
+                    Assert(pVCpu->em.s.enmState != EMSTATE_SUSPENDED);
                     pVCpu->em.s.enmPrevState = pVCpu->em.s.enmState;
                     pVCpu->em.s.enmState     = EMSTATE_SUSPENDED;
@@ -1988,4 +1991,5 @@
                 case VINF_EM_NO_MEMORY:
                     Log2(("EMR3ExecuteVM: VINF_EM_NO_MEMORY: %d -> %d\n", pVCpu->em.s.enmState, EMSTATE_SUSPENDED));
+                    Assert(pVCpu->em.s.enmState != EMSTATE_SUSPENDED);
                     pVCpu->em.s.enmPrevState = pVCpu->em.s.enmState;
                     pVCpu->em.s.enmState = EMSTATE_SUSPENDED;
