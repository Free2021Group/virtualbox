Description: fix dev unregistration issues on kernels 3.2.18 and newer
Origin: backport, https://www.virtualbox.org/changeset/41548/vbox
Bug: https://www.virtualbox.org/ticket/10624
Bug-Ubuntu: https://bugs.launchpad.net/bugs/1009156

--- a/src/VBox/HostDrivers/VBoxNetFlt/linux/VBoxNetFlt-linux.c
+++ b/src/VBox/HostDrivers/VBoxNetFlt/linux/VBoxNetFlt-linux.c
@@ -1536,4 +1536,6 @@
     pThis->u.s.PacketType.func = vboxNetFltLinuxPacketHandler;
     dev_add_pack(&pThis->u.s.PacketType);
+    ASMAtomicUoWriteBool(&pThis->u.s.fPacketHandler, true);
+    Log(("vboxNetFltLinuxAttachToInterface: this=%p: Packet handler installed.\n", pThis));
 
 #ifdef VBOXNETFLT_WITH_FILTER_HOST2GUEST_SKBS_EXPERIMENT
@@ -1560,5 +1562,4 @@
     }
     RTSpinlockReleaseNoInts(pThis->hSpinlock, &Tmp);
-    Log(("vboxNetFltLinuxAttachToInterface: this=%p: Packet handler installed.\n", pThis));
 
     /*
@@ -1604,4 +1605,5 @@
 static int vboxNetFltLinuxUnregisterDevice(PVBOXNETFLTINS pThis, struct net_device *pDev)
 {
+    bool fRegistered;
     RTSPINLOCKTMP Tmp = RTSPINLOCKTMP_INITIALIZER;
 
@@ -1610,24 +1612,35 @@
 #endif /* VBOXNETFLT_WITH_QDISC */
 
+    if (ASMAtomicCmpXchgBool(&pThis->u.s.fPacketHandler, false, true))
+    {
+        dev_remove_pack(&pThis->u.s.PacketType);
+        Log(("vboxNetFltLinuxUnregisterDevice: this=%p: packet handler removed.\n", pThis));
+    }
+
     RTSpinlockAcquireNoInts(pThis->hSpinlock, &Tmp);
-    ASMAtomicWriteBool(&pThis->u.s.fRegistered, false);
-    ASMAtomicWriteBool(&pThis->fDisconnectedFromHost, true);
-    ASMAtomicUoWriteNullPtr(&pThis->u.s.pDev);
+    fRegistered = ASMAtomicXchgBool(&pThis->u.s.fRegistered, false);
+    if (fRegistered)
+    {
+        ASMAtomicWriteBool(&pThis->fDisconnectedFromHost, true);
+        ASMAtomicUoWriteNullPtr(&pThis->u.s.pDev);
+    }
     RTSpinlockReleaseNoInts(pThis->hSpinlock, &Tmp);
 
-    dev_remove_pack(&pThis->u.s.PacketType);
+    if (fRegistered)
+    {
 #ifndef VBOXNETFLT_LINUX_NO_XMIT_QUEUE
-    skb_queue_purge(&pThis->u.s.XmitQueue);
-#endif
-    Log(("vboxNetFltLinuxUnregisterDevice: this=%p: Packet handler removed, xmit queue purged.\n", pThis));
-    Log(("vboxNetFltLinuxUnregisterDevice: Device %p(%s) released. ref=%d\n",
-         pDev, pDev->name,
+        skb_queue_purge(&pThis->u.s.XmitQueue);
+#endif
+        Log(("vboxNetFltLinuxUnregisterDevice: this=%p: xmit queue purged.\n", pThis));
+        Log(("vboxNetFltLinuxUnregisterDevice: Device %p(%s) released. ref=%d\n",
+             pDev, pDev->name,
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 37)
-         netdev_refcnt_read(pDev)
+             netdev_refcnt_read(pDev)
 #else
-         atomic_read(&pDev->refcnt)
-#endif
-         ));
-    dev_put(pDev);
+             atomic_read(&pDev->refcnt)
+#endif
+           ));
+        dev_put(pDev);
+    }
 
     return NOTIFY_OK;
@@ -1870,5 +1883,9 @@
      * we don't want the handler to forward packets to disconnected switch.
      */
-    dev_remove_pack(&pThis->u.s.PacketType);
+    if (ASMAtomicCmpXchgBool(&pThis->u.s.fPacketHandler, false, true))
+    {
+        dev_remove_pack(&pThis->u.s.PacketType);
+        Log(("vboxNetFltOsDisconnectIt: this=%p: Packet handler removed.\n", pThis));
+    }
     return VINF_SUCCESS;
 }
@@ -1917,5 +1934,5 @@
     RTSpinlockAcquireNoInts(pThis->hSpinlock, &Tmp);
     pDev = ASMAtomicUoReadPtrT(&pThis->u.s.pDev, struct net_device *);
-    fRegistered = ASMAtomicUoReadBool(&pThis->u.s.fRegistered);
+    fRegistered = ASMAtomicXchgBool(&pThis->u.s.fRegistered, false);
     RTSpinlockReleaseNoInts(pThis->hSpinlock, &Tmp);
 
@@ -1927,5 +1944,5 @@
         skb_queue_purge(&pThis->u.s.XmitQueue);
 #endif
-        Log(("vboxNetFltOsDeleteInstance: this=%p: Packet handler removed, xmit queue purged.\n", pThis));
+        Log(("vboxNetFltOsDeleteInstance: this=%p: xmit queue purged.\n", pThis));
         Log(("vboxNetFltOsDeleteInstance: Device %p(%s) released. ref=%d\n",
              pDev, pDev->name,
@@ -1974,6 +1991,7 @@
      */
     ASMAtomicUoWriteNullPtr(&pThis->u.s.pDev);
-    pThis->u.s.fRegistered = false;
+    pThis->u.s.fRegistered     = false;
     pThis->u.s.fPromiscuousSet = false;
+    pThis->u.s.fPacketHandler  = false;
     memset(&pThis->u.s.PacketType, 0, sizeof(pThis->u.s.PacketType));
 #ifndef VBOXNETFLT_LINUX_NO_XMIT_QUEUE
--- a/src/VBox/HostDrivers/VBoxNetFlt/VBoxNetFltInternal.h
+++ b/src/VBox/HostDrivers/VBoxNetFlt/VBoxNetFltInternal.h
@@ -165,4 +165,6 @@
             /** Whether device exists and physically attached. */
             bool volatile fRegistered;
+            /** Whether our packet handler is installed. */
+            bool volatile fPacketHandler;
             /** The MAC address of the interface. */
             RTMAC MacAddr;
